searchState.loadedDescShard("zune_jpeg", 0, "This crate provides a library for decoding valid ITU-T …\nA struct representing Image Information\nA JPEG Decoder Instance.\nNumber of components\nDecode a buffer already in memory\nRead only headers from a jpeg image buffer\nDecode into a pre-allocated buffer\nGet image dimensions as a tuple of width and height or <code>None</code>…\nContains most common errors that may be encountered in …\nReturn the exif data for the file\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the input colorspace of the image\nGet a mutable reference to the decoder options for the …\nGet the output colorspace the image pixels will be decoded …\nHeight of image\nGet the embedded ICC profile if it exists and is correct\nReturns the image information\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new Decoder instance\nCreate a new decoder with the specified options to be used …\nReturn the number of bytes required to hold a decoded …\nPixelDensity\nSet decoder options\nStart of frame markers\nWidth of the image\nHorizontal sample\nVertical sample\nCommon Decode errors\nDiscrete Quantization Tables error\nExhausted data\nExtended sequential DEC, arithmetic coding\nSOF_1 Extended sequential DCT,Huffman coding\nAny other thing we do not know\nAny other thing we do not know but we don’t need to …\nproblems with the Huffman Tables in a Decoder file\nIllegal Magic Bytes\nLarge image dimensions(Corrupted data)?\nLossless ( sequential), arithmetic coding\nLossless (sequential), huffman coding,\nMCU errors\nProgressive DCT, arithmetic coding,\nStart of frame errors\nStart of scan errors\nToo small output for size\nUnsupportedImages\nContains Unsupported/Yet-to-be supported Decoder image …\nImage has zero width\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an unsupported scheme from an integer\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")