<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rusty Object Notation"><title>ron - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ron" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ron/index.html">ron</a><span class="version">0.11.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#rusty-object-notation" title="Rusty Object Notation">Rusty Object Notation</a><ul><li><a href="#example" title="Example">Example</a></li><li><a href="#ron-syntax-overview" title="RON syntax overview">RON syntax overview</a></li><li><a href="#specification" title="Specification">Specification</a></li><li><a href="#why-ron" title="Why RON?">Why RON?</a></li><li><a href="#quickstart" title="Quickstart">Quickstart</a></li><li><a href="#tooling" title="Tooling">Tooling</a></li><li><a href="#limitations" title="Limitations">Limitations</a></li><li><a href="#license" title="License">License</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>ron</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ron/lib.rs.html#1-44">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="rusty-object-notation"><a class="doc-anchor" href="#rusty-object-notation">§</a>Rusty Object Notation</h2>
<p><a href="https://github.com/ron-rs/ron"><img src="https://img.shields.io/badge/MSRV-1.64.0-orange" alt="MSRV" /></a>
<a href="https://crates.io/crates/ron"><img src="https://img.shields.io/crates/v/ron.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/ron"><img src="https://docs.rs/ron/badge.svg" alt="Docs" /></a></p>
<p><a href="https://github.com/ron-rs/ron/actions/workflows/ci.yaml"><img src="https://github.com/ron-rs/ron/actions/workflows/ci.yaml/badge.svg" alt="CI" /></a>
<a href="https://ron-rs.github.io/ron/coverage/"><img src="https://img.shields.io/endpoint?url=https%3A%2F%2Fron-rs.github.io%2Fron%2Fcoverage%2Fcoverage.json" alt="Coverage" /></a>
<a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&amp;can=1&amp;q=proj:ron"><img src="https://oss-fuzz-build-logs.storage.googleapis.com/badges/ron.svg" alt="Fuzzing" /></a></p>
<p><a href="https://matrix.to/#/#ron-rs:matrix.org"><img src="https://img.shields.io/matrix/ron-rs:matrix.org.svg" alt="Matrix" /></a></p>
<p>RON is a simple readable data serialization format that looks similar to Rust syntax.
It’s designed to support all of <a href="https://serde.rs/data-model.html">Serde’s data model</a>, so
structs, enums, tuples, arrays, generic maps, and primitive values.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3><div class="example-wrap"><pre class="language-ron"><code>GameConfig( // optional struct name
    window_size: (800, 600),
    window_title: &quot;PAC-MAN&quot;,
    fullscreen: false,

    mouse_sensitivity: 1.4,
    key_bindings: {
        &quot;up&quot;: Up,
        &quot;down&quot;: Down,
        &quot;left&quot;: Left,
        &quot;right&quot;: Right,

        // Uncomment to enable WASD controls
        /*
        &quot;W&quot;: Up,
        &quot;S&quot;: Down,
        &quot;A&quot;: Left,
        &quot;D&quot;: Right,
        */
    },

    difficulty_options: (
        start_difficulty: Easy,
        adaptive: false,
    ),
)</code></pre></div><h3 id="ron-syntax-overview"><a class="doc-anchor" href="#ron-syntax-overview">§</a>RON syntax overview</h3>
<ul>
<li>Numbers: <code>42</code>, <code>3.14</code>, <code>0xFF</code>, <code>0b0110</code></li>
<li>Strings: <code>"Hello"</code>, <code>"with\\escapes\n"</code>, <code>r#"raw string, great for regex\."#</code></li>
<li>Byte Strings: <code>b"Hello"</code>, <code>b"with \x65\x73\x63\x61\x70\x65\x73\n"</code>, <code>br#"raw, too"#</code></li>
<li>Booleans: <code>true</code>, <code>false</code></li>
<li>Chars: <code>'e'</code>, <code>'\n'</code></li>
<li>Optionals: <code>Some("string")</code>, <code>Some(Some(1.34))</code>, <code>None</code></li>
<li>Tuples: <code>("abc", 1.23, true)</code>, <code>()</code></li>
<li>Lists: <code>["abc", "def"]</code></li>
<li>Structs: <code>( foo: 1.0, bar: ( baz: "I'm nested" ) )</code></li>
<li>Maps: <code>{ "arbitrary": "keys", "are": "allowed" }</code></li>
</ul>
<blockquote>
<p><strong>Note:</strong> Serde’s data model represents fixed-size Rust arrays as tuple (instead of as list)</p>
</blockquote>
<p>RON also supports several extensions, which are documented <a href="docs/extensions.md">here</a>.</p>
<h3 id="specification"><a class="doc-anchor" href="#specification">§</a>Specification</h3>
<p>RON’s formal and complete grammar is available <a href="docs/grammar.md">here</a>.</p>
<p>There also is a very basic, work in progress specification available on
<a href="https://github.com/ron-rs/ron/wiki/Specification">the wiki page</a>.</p>
<h3 id="why-ron"><a class="doc-anchor" href="#why-ron">§</a>Why RON?</h3><h4 id="example-in-json"><a class="doc-anchor" href="#example-in-json">§</a>Example in JSON</h4><div class="example-wrap"><pre class="language-json"><code>{
   &quot;materials&quot;: {
        &quot;metal&quot;: {
            &quot;reflectivity&quot;: 1.0
        },
        &quot;plastic&quot;: {
            &quot;reflectivity&quot;: 0.5
        }
   },
   &quot;entities&quot;: [
        {
            &quot;name&quot;: &quot;hero&quot;,
            &quot;material&quot;: &quot;metal&quot;
        },
        {
            &quot;name&quot;: &quot;monster&quot;,
            &quot;material&quot;: &quot;plastic&quot;
        }
   ]
}</code></pre></div><h4 id="same-example-in-ron"><a class="doc-anchor" href="#same-example-in-ron">§</a>Same example in RON</h4><div class="example-wrap"><pre class="language-ron"><code>Scene( // class name is optional
    materials: { // this is a map
        &quot;metal&quot;: (
            reflectivity: 1.0,
        ),
        &quot;plastic&quot;: (
            reflectivity: 0.5,
        ),
    },
    entities: [ // this is an array
        (
            name: &quot;hero&quot;,
            material: &quot;metal&quot;,
        ),
        (
            name: &quot;monster&quot;,
            material: &quot;plastic&quot;,
        ),
    ],
)</code></pre></div>
<p>Note the following advantages of RON over JSON:</p>
<ul>
<li>trailing commas allowed</li>
<li>single- and multi-line comments</li>
<li>field names aren’t quoted, so it’s less verbose</li>
<li>optional struct names improve readability</li>
<li>enums are supported (and less verbose than their JSON representation)</li>
</ul>
<h3 id="quickstart"><a class="doc-anchor" href="#quickstart">§</a>Quickstart</h3><h4 id="cargotoml"><a class="doc-anchor" href="#cargotoml">§</a><code>Cargo.toml</code></h4><div class="example-wrap"><pre class="language-toml"><code>[dependencies]
ron = &quot;0.8&quot;
serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }</code></pre></div><h4 id="mainrs"><a class="doc-anchor" href="#mainrs">§</a><code>main.rs</code></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>serde::{Deserialize, Serialize};

<span class="attr">#[derive(Debug, Deserialize, Serialize)]
</span><span class="kw">struct </span>MyStruct {
    boolean: bool,
    float: f32,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>x: MyStruct = ron::from_str(<span class="string">"(boolean: true, float: 1.23)"</span>).unwrap();

    <span class="macro">println!</span>(<span class="string">"RON: {}"</span>, ron::to_string(<span class="kw-2">&amp;</span>x).unwrap());

    <span class="macro">println!</span>(<span class="string">"Pretty RON: {}"</span>, ron::ser::to_string_pretty(
        <span class="kw-2">&amp;</span>x, ron::ser::PrettyConfig::default()).unwrap(),
    );
}</code></pre></div>
<h3 id="tooling"><a class="doc-anchor" href="#tooling">§</a>Tooling</h3><div><table><thead><tr><th>Editor</th><th>Plugin</th></tr></thead><tbody>
<tr><td>IntelliJ</td><td><a href="https://github.com/ron-rs/intellij-ron">intellij-ron</a></td></tr>
<tr><td>VS Code</td><td><a href="https://github.com/a5huynh/vscode-ron">a5huynh/vscode-ron</a></td></tr>
<tr><td>Sublime Text</td><td><a href="https://packagecontrol.io/packages/RON">RON</a></td></tr>
<tr><td>Atom</td><td><a href="https://atom.io/packages/language-ron">language-ron</a></td></tr>
<tr><td>Vim</td><td><a href="https://github.com/ron-rs/ron.vim">ron-rs/ron.vim</a></td></tr>
<tr><td>EMACS</td><td><a href="https://chiselapp.com/user/Hutzdog/repository/ron-mode/home">emacs-ron</a></td></tr>
</tbody></table>
</div><h3 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h3>
<p>RON requires struct, enum, and variant names to be valid Rust identifiers and will reject invalid ones created by <code>#[serde(rename = "...")]</code> at serialization / deserialization time.</p>
<p>RON is not designed to be a fully self-describing format (unlike JSON) and is thus not guaranteed to work when <a href="https://docs.rs/serde/latest/serde/trait.Deserializer.html#tymethod.deserialize_any"><code>deserialize_any</code></a> is used instead of its typed alternatives. In particular, the following Serde attributes only have limited support:</p>
<ul>
<li><code>#[serde(tag = "tag")]</code>, i.e. internally tagged enums <sup id="fnref1"><a href="#fn1">1</a></sup></li>
<li><code>#[serde(tag = "tag", content = "content")]</code>, i.e. adjacently tagged enums <sup id="fnref1"><a href="#fn1">1</a></sup></li>
<li><code>#[serde(untagged)]</code>, i.e. untagged enums <sup id="fnref1"><a href="#fn1">1</a></sup></li>
<li><code>#[serde(flatten)]</code>, i.e. flattening of structs into maps <sup id="fnref2"><a href="#fn2">2</a></sup></li>
</ul>
<p>While data structures with any of these attributes should generally roundtrip through RON, some restrictions apply <sup id="fnref3"><a href="#fn3">3</a></sup> and their textual representation may not always match your expectation:</p>
<ul>
<li>ron only supports string keys inside maps flattened into structs</li>
<li>internally (or adjacently) tagged or untagged enum variants or <code>#[serde(flatten)]</code>ed fields must not contain:
<ul>
<li>struct names, e.g. by enabling the <code>#[enable(explicit_struct_names)]</code> extension or the <code>PrettyConfig::struct_names</code> setting</li>
<li>newtypes</li>
<li>zero-length arrays / tuples / tuple structs / structs / tuple variants / struct variants
<ul>
<li><code>Option</code>s with <code>#[enable(implicit_some)]</code> must not contain any of these or a unit, unit struct, or an untagged unit variant</li>
</ul>
</li>
<li>externally tagged tuple variants with just one field (that are not newtype variants)</li>
<li>tuples or arrays or tuple structs with just one element are not supported inside newtype variants with <code>#[enable(unwrap_variant_newtypes)]</code> (including <code>Some</code>)</li>
<li>a <code>ron::value::RawValue</code></li>
</ul>
</li>
<li>untagged tuple / struct variants with no fields are not supported</li>
<li>untagged tuple variants with just one field (that are not newtype variants) are not supported when the <code>#![enable(unwrap_variant_newtypes)]</code> extension is enabled</li>
<li>serializing a <code>ron::value::RawValue</code> using a <code>PrettyConfig</code> may add leading and trailing whitespace and comments, which the <code>ron::value::RawValue</code> absorbs upon deserialization</li>
</ul>
<p>Furthermore, serde imposes the following restrictions for data to roundtrip:</p>
<ul>
<li>structs or struct variants that contain a <code>#[serde(flatten)]</code>ed field:
<ul>
<li>are only serialised as maps and deserialised from maps</li>
<li>must not contain duplicate fields / keys, e.g. where an inner-struct field matches an outer-struct or inner-struct field</li>
<li>must not contain more than one (within the super-struct of all flattened structs) <code>#[serde(flatten)]</code>ed map field, which collects all unknown fields</li>
<li>if they contain a <code>#[serde(flatten)]</code>ed map, they must not contain:
<ul>
<li>a struct that is not flattened itself but contains some flattened fields and is flattened into the outer struct (variant)</li>
<li>an untagged struct variant that contains some flattened fields</li>
<li>a flattened externally tagged newtype, tuple, or struct variant, flattened internally tagged unit, newtype, or struct variant, or any flattened adjacently tagged variant</li>
<li>a flattened tagged struct</li>
</ul>
</li>
</ul>
</li>
<li>internally (or adjacently) tagged or untagged enum variants or <code>#[serde(flatten)]</code>ed fields must not contain:
<ul>
<li><code>i128</code> or <code>u128</code> values</li>
</ul>
</li>
<li>internally tagged newtype variants and <code>#[serde(flatten)]</code>ed fields must not contain:
<ul>
<li>a unit or a unit struct inside an untagged newtype variant</li>
<li>an untagged unit variant</li>
</ul>
</li>
<li>internally tagged newtype variants, which are <code>#[serde(flatten)]</code>ed together with other fields, must not contain:
<ul>
<li>a unit or unit struct or an untagged unit variant</li>
</ul>
</li>
</ul>
<p>While RON offers a best-effort implementation for <code>#[serde(flatten)]</code>, it may be unsupported in further cases and combinations not listed above. These limitations stem primarily from serde rather than RON. Enumerating all such cases based on serde’s behavior is nontrivial, so the lists above are not exhaustive.</p>
<p>Please file a <a href="https://github.com/ron-rs/ron/issues/new">new issue</a> if you come across a use case which is not listed among the above restrictions but still breaks.</p>
<p>While RON guarantees roundtrips like Rust -&gt; RON -&gt; Rust for Rust types using non-<code>deserialize_any</code>-based implementations, RON does not yet make any guarantees about roundtrips through <code>ron::Value</code>. For instance, even when RON -&gt; Rust works, RON -&gt; <code>ron::Value</code> -&gt; Rust, or RON -&gt; <code>ron::Value</code> -&gt; RON -&gt; Rust may not work. We plan on improving <code>ron::Value</code> in an upcoming version of RON, though this work is partially blocked on <a href="https://github.com/serde-rs/serde/issues/1183">serde#1183</a>.</p>
<h3 id="license"><a class="doc-anchor" href="#license">§</a>License</h3>
<p>RON is dual-licensed under Apache-2.0 and MIT.</p>
<p>Any contribution intentionally submitted for inclusion in the work must be provided under the same dual-license terms.</p>
<div class="footnotes"><hr><ol><li id="fn1"><p>Deserialising an internally, adjacently, or un-tagged enum requires detecting <code>serde</code>’s internal <code>serde::__private::de::content::Content</code> content type so that RON can describe the deserialised data structure in serde’s internal JSON-like format. This detection only works for the automatically-derived <a href="https://docs.rs/serde/latest/serde/de/trait.Deserialize.html"><code>Deserialize</code></a> impls on enums. See <a href="https://github.com/ron-rs/ron/pull/451">#451</a> for more details.&nbsp;<a href="#fnref1">↩</a></p></li><li id="fn2"><p>Deserialising a flattened struct from a map requires that the struct’s <a href="https://docs.rs/serde/latest/serde/de/trait.Visitor.html#tymethod.expecting"><code>Visitor::expecting</code></a> implementation formats a string starting with <code>"struct "</code>. This is the case for automatically-derived <a href="https://docs.rs/serde/latest/serde/de/trait.Deserialize.html"><code>Deserialize</code></a> impls on structs. See <a href="https://github.com/ron-rs/ron/pull/455">#455</a> for more details.&nbsp;<a href="#fnref2">↩</a></p></li><li id="fn3"><p>Most of these restrictions are currently blocked on <a href="https://github.com/serde-rs/serde/issues/1183">serde#1183</a>, which limits non-self-describing formats from roundtripping format-specific information through internally (or adjacently) tagged or untagged enums or <code>#[serde(flatten)]</code>ed fields.&nbsp;<a href="#fnref3">↩</a></p></li></ol></div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.from_str"><code>pub use de::<a class="fn" href="de/fn.from_str.html" title="fn ron::de::from_str">from_str</a>;</code></dt><dt id="reexport.Deserializer"><code>pub use de::<a class="struct" href="de/struct.Deserializer.html" title="struct ron::de::Deserializer">Deserializer</a>;</code></dt><dt id="reexport.Error"><code>pub use error::<a class="enum" href="error/enum.Error.html" title="enum ron::error::Error">Error</a>;</code></dt><dt id="reexport.Result"><code>pub use error::<a class="type" href="error/type.Result.html" title="type ron::error::Result">Result</a>;</code></dt><dt id="reexport.Options"><code>pub use options::<a class="struct" href="options/struct.Options.html" title="struct ron::options::Options">Options</a>;</code></dt><dt id="reexport.to_string"><code>pub use ser::<a class="fn" href="ser/fn.to_string.html" title="fn ron::ser::to_string">to_string</a>;</code></dt><dt id="reexport.Serializer"><code>pub use ser::<a class="struct" href="ser/struct.Serializer.html" title="struct ron::ser::Serializer">Serializer</a>;</code></dt><dt id="reexport.Map"><code>pub use value::<a class="struct" href="value/struct.Map.html" title="struct ron::value::Map">Map</a>;</code></dt><dt id="reexport.Number"><code>pub use value::<a class="enum" href="value/enum.Number.html" title="enum ron::value::Number">Number</a>;</code></dt><dt id="reexport.Value"><code>pub use value::<a class="enum" href="value/enum.Value.html" title="enum ron::value::Value">Value</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="de/index.html" title="mod ron::de">de</a></dt><dt><a class="mod" href="error/index.html" title="mod ron::error">error</a></dt><dt><a class="mod" href="extensions/index.html" title="mod ron::extensions">extensions</a></dt><dt><a class="mod" href="options/index.html" title="mod ron::options">options</a></dt><dd>Roundtrip serde Options module.</dd><dt><a class="mod" href="ser/index.html" title="mod ron::ser">ser</a></dt><dt><a class="mod" href="util/index.html" title="mod ron::util">util</a></dt><dt><a class="mod" href="value/index.html" title="mod ron::value">value</a></dt><dd>Value module.</dd></dl></section></div></main></body></html>